class PikachuComputer {

    field int x, y, vy, smashDirection, t, stopTime, spikedir;
    field boolean faceright, ontheair, sliding, stopping, spiking, pastColliding;
    static int dx, slide_x, sx, sy; // move per press, sizex, sizey
    constructor PikachuComputer new(boolean fr) {
        let x = 411;
        let y = 180;

        let faceright = fr;
        let ontheair = false;
        let sliding = false;
        let stopping = false;
        let pastColliding = false;

        let sx = 30;
        let sy = 60;

        let dx = 12;
        let slide_x = 10;
        return this;
    }

    method void movex(boolean dir){
        if (dir){
            let x = x + dx;
        }
        else {
            let x = x - dx;
        }
        return;
    }

    method void slidex(boolean dir){
        if (dir){
            let x = x + slide_x;
        }
        else{
            let x = x - slide_x;
        }
        return;
    }

    method void movey() {
        var int dt, dy;
        let dt = Phys.getDt();

        let dy = dt*vy;
        let y = y + dy;
        return;
    }

    method void jump(){
        let vy = -15;
        return;
    }

    method void groundPrevent() {
        if (y > (Phys.getGround()-1-sy)) {
            let vy = 0;
            let y = Phys.getGround()-sy;
        }
        return;
    }

    method void gravity() {
        var int dvy;
        let dvy = Phys.getDvy();
        let vy = vy + dvy;
        return;
    }

    method void wallPrevent() {
        if(x > (512-1-sx)) {
            let x = (512-1-sx);
        }
        if(x < 246) {
            let x = 246;
        }
        return;
    }

    method void statusChange() {
        if (y > (Phys.getGround()-1-sy)) {
            let ontheair = false;
            if (sliding){
                let stopping = true;
                let sliding = false;
            }
        }
        else {
            let ontheair = true;
        }
        return;
    }

    method void interactWithBall() {
        var Ball b;
        let b = PhysicsManager.getBall();
        if (spiking){
            do spike();
            let spiking = false;
        }
        else{
            if (faceright) {
                do b.setVx(15);
            }
            else {
                do b.setVx(-15);
            }
            do b.setVy(-15);
        }
        return;
    }

    method int collideWithBall() {
        var boolean isColliding;
        let isColliding = collisionDetection();
        if (isColliding) {
            if (pastColliding) {
                return false;
            }
            else {
                let pastColliding = true;
                return true;
            }
        }
        else {
            let pastColliding = false;
            return false;
        }
    }

    method boolean collisionDetection() {
        var Ball b;
        var int bx, by, r;
        let b = PhysicsManager.getBall();
        let bx = b.getx();
        let by = b.gety();
        let r = b.size();

        if (ballOnOtherSide()) {
            return false;
        }

        if (bx < x) {
            if (by < y) {
                return Util.le(Util.dist(bx, by, x, y), r);
            }
            if (by > (y+sy)) {
                return Util.le(Util.dist(bx, by, x, y+sy), r);
            }
            return (x-bx) < r;
        }

        if (bx > (x+sx)) {
            if (by < y) {
                return Util.le(Util.dist(bx, by, x+sx, y), r);
            }
            if (by > (y+sy)) {
                return Util.le(Util.dist(bx, by, x+sx, y+sy), r);
            }
            return (bx-x-sx) < r;
        }

        if (by < y) {
            return (y-by) < r;
        }
        if (by > (y+sy)) {
            return (by-y-sy) < r;
        }
        return true;
    }

    method void update() {
        let t = t + 1;
        if (collideWithBall()) {
            do interactWithBall();
        }
        if (stopping) {
            if ((t - stopTime) > 15) {
                let stopping = false;
            }
            return;
        }
        if (sliding){
            do slidex(faceright);
        }
        else{
            do decide();          
        }
        do movey();
        do gravity();
        do groundPrevent();
        do wallPrevent();
        do statusChange();
        return;
    }


    method void render() {
        if (~(sliding)){
            do Screen.drawRectangle(x, y, x+sx, y+sy);
        }
        else{
            if (faceright){
                do Screen.drawRectangle(x, y, x+sy, y+sx);
            }
            else{
                do Screen.drawRectangle(x, y, x+sy, y+sx);
            }
            
        }
        return;
    }

    method void spike(){
        var Ball b;
        var int smashSpeedx, smashSpeedy;
        let b = PhysicsManager.getBall();
        let smashSpeedx = 20;
        let smashSpeedy = 20;
        if (ontheair & (x = 133)) {
            do b.setVx(smashSpeedx);
            do b.setVy(smashSpeedy);
        }
        return;
    }

    method void slide(){
        let vy = -5;
        let ontheair = true;
        let sliding = true;
        let stopTime = t;
        return;
    }
    method void decide() {
        do moveToLanding();
        return;
    }

    method void moveToLanding() {
        var int nx, mx;
        var Rod r;

        let r = PhysicsManager.getRod();
        
        let nx = Util.calculateLanding(PhysicsManager.getBall(), y, y+sy);
        if (nx < r.getLeft()) {
            return;
        }
        // do Screen.drawRectangle(nx, 0, nx+15, 20);
        let mx = x+(sx/2);
        if (nx < mx) {
            do movex(0);
        }
        else {
            do movex(-1);
        }
        return;
    }

    method boolean ballOnOtherSide() {
        var Rod r;
        var Ball b;
        let r = PhysicsManager.getRod();
        let b = PhysicsManager.getBall();
        return (b.getx() < r.getLeft());
    }

    method void reset(){
        let x = 411;
        let y = 180;
        let vy = 0;
        
        let faceright = false;
        let ontheair = false;
        let sliding = false;
        let stopping = false;

        return;
    }
}